---
layout: page
title: To Do
---
<p><a href="../tex/todo.bib">BibTeX</a> | <a href="../tex/todo.pdf">PDF</a></p>

<p><a href="#A">A</a> <a href="#B">B</a> <a href="#C">C</a> <a href="#D">D</a> <a href="#E">E</a> <a href="#F">F</a> <a href="#G">G</a> <a href="#H">H</a> <a href="#I">I</a> <a href="#J">J</a> <a href="#K">K</a> <a href="#L">L</a> <a href="#M">M</a> <a href="#N">N</a> <a href="#O">O</a> <a href="#P">P</a> <a href="#Q">Q</a> <a href="#R">R</a> <a href="#S">S</a> <a href="#T">T</a> <a href="#U">U</a> <a href="#V">V</a> <a href="#W">W</a> <a href="#X">X</a> <a href="#Y">Y</a> <a href="#Z">Z</a></p>

<h2 id="A">A</h2>

<p id="Andersen2020" class="bib"><cite>Andersen2020</cite>
Leif Andersen, Michael Ballantyne, and Matthias Felleisen:
"<a href="https://doi.org/10.1145/3428290">Adding interactive visual syntax to textual code</a>".
<em>Proceedings of the ACM on Programming Languages</em>, 4(OOPSLA), 2020,
<a class="doi" href="https://doi.org/10.1145/3428290">10.1145/3428290</a>.
</p>
<blockquote class="abstract">Many programming problems call for turning geometrical thoughts into code: tables, hierarchical structures, nests of objects, trees, forests, graphs, and so on. Linear text does not do justice to such thoughts. But, it has been the dominant programming medium for the past and will remain so for the foreseeable future. This paper proposes a novel mechanism for conveniently extending textual programming languages with problem-specific visual syntax. It argues the necessity of this language feature, demonstrates the feasibility with a robust prototype, and sketches a design plan for adapting the idea to other languages.</blockquote>

<h2 id="B">B</h2>

<p id="Bi2021" class="bib"><cite>Bi2021</cite>
Tingting Bi, Wei Ding, Peng Liang, and Antony Tang:
"<a href="https://doi.org/10.1016/j.jss.2021.111035">Architecture information communication in two OSS projects: The why, who, when, and what</a>".
<em>Journal of Systems and Software</em>, 181, 2021,
<a class="doi" href="https://doi.org/10.1016/j.jss.2021.111035">10.1016/j.jss.2021.111035</a>.
</p>
<blockquote class="abstract">Architecture information is vital for Open Source Software (OSS) development, and mailing list is one of the widely used channels for developers to share and communicate architecture information. This work investigates the nature of architecture information communication (i.e., why, who, when, and what) by OSS developers via developer mailing lists. We employed a multiple case study approach to extract and analyze the architecture information communication from the developer mailing lists of two OSS projects, ArgoUML and Hibernate, during their development life-cycle of over 18 years. Our main findings are: (a) architecture negotiation and interpretation are the two main reasons (i.e., why) of architecture communication; (b) the amount of architecture information communicated in developer mailing lists decreases after the first stable release (i.e., when); (c) architecture communications centered around a few core developers (i.e., who); (d) and the most frequently communicated architecture elements (i.e., what) are Architecture Rationale and Architecture Model. There are a few similarities of architecture communication between the two OSS projects. Such similarities point to how OSS developers naturally gravitate towards the four aspects of architecture communication in OSS development.</blockquote>

<p id="Blackwell2019" class="bib"><cite>Blackwell2019</cite>
Alan F. Blackwell, Marian Petre, and Luke Church:
"<a href="https://doi.org/10.1016/j.ijhcs.2019.06.009">Fifty years of the psychology of programming</a>".
<em>International Journal of Human-Computer Studies</em>, 131, 2019,
<a class="doi" href="https://doi.org/10.1016/j.ijhcs.2019.06.009">10.1016/j.ijhcs.2019.06.009</a>.
</p>
<blockquote class="abstract">Abstract This paper reflects on the evolution (past, present and future) of the 'psychology of programming' over the 50 year period of this anniversary issue. The International Journal of Human-Computer Studies (IJHCS) has been a key venue for much seminal work in this field, including its first foundations, and we review the changing research concerns seen in publications over these five decades. We relate this thematic evolution to research taking place over the same period within more specialist communities, especially the Psychology of Programming Interest Group (PPIG), the Empirical Studies of Programming series (ESP), and the ongoing community in Visual Languages and Human-Centric Computing (VL/HCC). Many other communities have interacted with psychology of programming, both influenced by research published within the specialist groups, and in turn influencing research priorities. We end with an overview of the core theories that have been developed over this period, as an introductory resource for new researchers, and also with the authors' own analysis of key priorities for future research.</blockquote>

<h2 id="C">C</h2>
<h2 id="D">D</h2>

<p id="Dias2021" class="bib"><cite>Dias2021</cite>
Edson Dias, Paulo Meirelles, Fernando Castor, Igor Steinmacher, Igor Wiese, and Gustavo Pinto:
"<a href="https://doi.org/10.1109/icse43902.2021.00093">What Makes a Great Maintainer of Open Source Projects?</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00093">10.1109/icse43902.2021.00093</a>.
</p>
<blockquote class="abstract">Although Open Source Software (OSS) maintainers devote a significant proportion of their work to coding tasks, great maintainers must excel in many other activities beyond coding. Maintainers should care about fostering a community, helping new members to find their place, while also saying ``no'' to patches that although are well-coded and well-tested, do not contribute to the goal of the project. To perform all these activities masterfully, maintainers should exercise attributes that software engineers (working on closed source projects) do not always need to master. This paper aims to uncover, relate, and prioritize the unique attributes that great OSS maintainers might have. To achieve this goal, we conducted 33 semi-structured interviews with well-experienced maintainers that are the gatekeepers of notable projects such as the Linux Kernel, the Debian operating system, and the GitLab coding platform. After we analyzed the interviews and curated a list of attributes, we created a conceptual framework to explain how these attributes are connected. We then conducted a rating survey with 90 OSS contributors. We noted that ``technical excellence'' and ``communication'' are the most recurring attributes. When grouped, these attributes fit into four broad categories: management, social, technical, and personality. While we noted that ``sustain a long term vision of the project'' and being ``extremely careful'' seem to form the basis of our framework, we noted through our survey that the communication attribute was perceived as the most essential one.</blockquote>

<h2 id="E">E</h2>
<h2 id="F">F</h2>

<p id="Farzat2021" class="bib"><cite>Farzat2021</cite>
Fabio de A. Farzat, Marcio de O. Barros, and Guilherme H. Travassos:
"<a href="https://doi.org/10.1109/tse.2019.2928293">Evolving JavaScript Code to Reduce Load Time</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(8), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2928293">10.1109/tse.2019.2928293</a>.
</p>
<blockquote class="abstract">JavaScript is one of the most used programming languages for front-end development of Web applications. The increase in complexity of front-end features brings concerns about performance, especially the load and execution time of JavaScript code. In this paper, we propose an evolutionary program improvement technique to reduce the size of JavaScript programs and, therefore, the time required to load and execute them in Web applications. To guide the development of this technique, we performed an experimental study to characterize the patches applied to JavaScript programs to reduce their size while keeping the functionality required to pass all test cases in their test suites. We applied this technique to 19 JavaScript programs varying from 92 to 15,602 LOC and observed reductions from 0.2 to 73.8 percent of the original code, as well as a relationship between the quality of a program's test suite and the ability to reduce the size of its source code.</blockquote>

<p id="Feal2020" class="bib"><cite>Feal2020</cite>
'Alvaro Feal, Paolo Calciati, Narseo Vallina-Rodriguez, Carmela Troncoso, and Alessandra Gorla:
"<a href="https://doi.org/10.2478/popets-2020-0029">Angel or Devil? A Privacy Study of Mobile Parental Control Apps</a>".
<em>Proceedings on Privacy Enhancing Technologies</em>, 2020(2), 2020,
<a class="doi" href="https://doi.org/10.2478/popets-2020-0029">10.2478/popets-2020-0029</a>.
</p>
<blockquote class="abstract">Android parental control applications are used by parents to monitor and limit their children's mobile behaviour (e.g., mobile apps usage, web browsing, calling, and texting). In order to offer this service, parental control apps require privileged access to sys-tem resources and access to sensitive data. This may significantly reduce the dangers associated with kids' online activities, but it raises important privacy con-cerns. These concerns have so far been overlooked by organizations providing recommendations regarding the use of parental control applications to the public. We conduct the first in-depth study of the Android parental control app's ecosystem from a privacy and regulatory point of view. We exhaustively study 46 apps from 43 developers which have a combined 20M installs in the Google Play Store. Using a combination of static and dynamic analysis we find that: these apps are on average more permissions-hungry than the top 150 apps in the Google Play Store, and tend to request more dangerous permissions with new releases; 11% of the apps transmit personal data in the clear; 34% of the apps gather and send personal information without appropriate consent; and 72% of the apps share data with third parties (including online advertising and analytics services) without mentioning their presence in their privacy policies. In summary, parental control applications lack transparency and lack compliance with reg ulatory requirements. This holds even for those applications recommended by European and other national security centers.</blockquote>

<p id="Ferreira2022" class="bib"><cite>Ferreira2022</cite>
Fabio Ferreira, Hudson Silva Borges, and Marco Tulio Valente:
"<a href="https://doi.org/10.1002/spe.3044">On the (un-)adoption of JavaScript front-end frameworks</a>".
<em>Software: Practice and Experience</em>, 52(4), 2021,
<a class="doi" href="https://doi.org/10.1002/spe.3044">10.1002/spe.3044</a>.
</p>
<blockquote class="abstract">JavaScript is characterized by a rich ecosystem of libraries and frameworks. A key element in this ecosystem are frameworks used for implementing the front-end of web-based applications, such as Vue and React. However, despite their relevance, we have few works investigating the factors that drive the adoption—and un-adoption—of front-end-based JavaScript frameworks. Therefore, in this article, we first report the results of a survey with 49 developers where we asked them to describe the factors they consider when selecting a front-end framework. In the second part of the work, we focus on projects that migrate from one framework to another since JavaScript's ecosystem is also very dynamic. Finally, we provide a quantitative characterization of the migration effort and reveal the main barriers faced by the developers during this effort. Although not completely generalizable, our central findings are as follows: (a) popularity and learnability are the key factors that motivate the choice of front-end frameworks in JavaScript; (b) from the 49 surveyed developers, one out of four have plans to migrate to another framework in the future; (c) the time spent performing the migration is greater than or equal to the time spent using the old framework in all studied projects. We conclude with a list of implications for practitioners, framework developers, tool builders, and researchers.</blockquote>

<h2 id="G">G</h2>
<h2 id="H">H</h2>

<p id="Hoda2021" class="bib"><cite>Hoda2021</cite>
Rashina Hoda:
"<a href="https://doi.org/10.1109/tse.2021.3106280">Socio-Technical Grounded Theory for Software Engineering</a>".
<em>IEEE Transactions on Software Engineering</em>, 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2021.3106280">10.1109/tse.2021.3106280</a>.
</p>
<blockquote class="abstract">Grounded Theory (GT), a sociological research method designed to study social phenomena, is increasingly being used to investigate the human and social aspects of software engineering (SE). However, being written by and for sociologists, GT is often challenging for a majority of SE researchers to understand and apply. Additionally, SE researchers attempting ad hoc adaptations of traditional GT guidelines for modern socio-technical (ST) contexts often struggle in the absence of clear and relevant guidelines to do so, resulting in poor quality studies. To overcome these research community challenges and leverage modern research opportunities, this paper presents Socio-Technical Grounded Theory (STGT) designed to ease application and achieve quality outcomes. It defines what exactly is meant by an ST research context and presents the STGT guidelines that expand GT's philosophical foundations, provide increased clarity and flexibility in its methodological steps and procedures, define possible scope and contexts of application, encourage frequent reporting of a variety of interim, preliminary, and mature outcomes, and introduce nuanced evaluation guidelines for different outcomes. It is hoped that the SE research community and related ST disciplines such as computer science, data science, artificial intelligence, information systems, human computer/robot/AI interaction, human-centered emerging technologies (and increasingly other disciplines being transformed by rapid digitalisation and AI-based augmentation), will benefit from applying STGT to conduct quality research studies and systematically produce rich findings and mature theories with confidence.</blockquote>

<h2 id="I">I</h2>

<p id="Imam2021" class="bib"><cite>Imam2021</cite>
Ahmed Imam and Tapajit Dey:
"<a href="https://doi.org/10.1109/msr52588.2021.00085">Tracking Hackathon Code Creation and Reuse</a>".
<em>Proc. International Conference on Mining Software Repositories (MSR)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00085">10.1109/msr52588.2021.00085</a>.
</p>
<blockquote class="abstract">Background: Hackathons have become popular events for teams to collaborate on projects and develop software prototypes. Most existing research focuses on activities during an event with limited attention to the evolution of the code brought to or created during a hackathon. Aim: We aim to understand the evolution of hackathon-related code, specifically, how much hackathon teams rely on pre-existing code or how much new code they develop during a hackathon. Moreover, we aim to understand if and where that code gets reused. Method: We collected information about 22,183 hackathon projects from Devpost—a hackathon database—and obtained related code (blobs), authors, and project characteristics from the World of Code. We investigated if code blobs in hackathon projects were created before, during, or after an event by identifying the original blob creation date and author, and also checked if the original author was a hackathon project member. We tracked code reuse by first identifying all commits containing blobs created during an event before determining all projects that contain those commits. Result: While only approximately 9.14% of the code blobs are created during hackathons, this amount is still significant considering time and member constraints of such events. Approximately a third of these code blobs get reused in other projects. Conclusion: Our study demonstrates to what extent pre-existing code is used and new code is created during a hackathon and how much of it is reused elsewhere afterwards. Our findings help to better understand code reuse as a phenomenon and the role of hackathons in this context and can serve as a starting point for further studies in this area.</blockquote>

<h2 id="J">J</h2>

<p id="Johnson2016" class="bib"><cite>Johnson2016</cite>
Philip Johnson, Dan Port, and Emily Hill:
"<a href="https://doi.org/10.1109/cseet.2016.29">An Athletic Approach to Software Engineering Education</a>".
<em>2016 IEEE 29th International Conference on Software Engineering Education and Training (CSEET)</em>, 2016, <a class="doi" href="https://doi.org/10.1109/cseet.2016.29">10.1109/cseet.2016.29</a>.
</p>
<blockquote class="abstract">We present our findings after two years of experience involving three instructors using an "athletic" approach to software engineering education (AthSE). Co-author Johnson developed AthSE in 2013 to address issues he experienced teaching graduate and undergraduate software engineering. Co-authors Port and Hill subsequently adapted the original approach to their own software courses. AthSE is a pedagogy in which the course is organized into a series of skills to be mastered. For each skill, students are given practice "Workouts" along with videos showing the instructor performing the Workout both correctly and quickly. Unlike traditional home-work assignments, students are advised to repeat the Workout not only until they can complete it correctly, but also as quickly as the instructor. In this experience report we investigate the following question: how can software engineering education be redesigned as an athletic endeavor, and will this provide more efficient and effective learning among students and more rapidly lead them to greater competency and confidence?</blockquote>

<h2 id="K">K</h2>

<p id="Kuttal2021" class="bib"><cite>Kuttal2021</cite>
Sandeep Kaur Kuttal, Xiaofan Chen, Zhendong Wang, Sogol Balali, and Anita Sarma:
"<a href="https://doi.org/10.1016/j.infsof.2021.106633">Visual Resume: Exploring developers' online contributions for hiring</a>".
<em>Information and Software Technology</em>, 138, 2021,
<a class="doi" href="https://doi.org/10.1016/j.infsof.2021.106633">10.1016/j.infsof.2021.106633</a>.
</p>
<blockquote class="abstract">Context: Recruiters and practitioners are increasingly relying on online activities of developers to find a suitable candidate. Past empirical studies have identified technical and soft skills that managers use in online peer production sites when making hiring decisions. However, finding candidates with relevant skills is a labor-intensive task for managers, due to the sheer amount of information online peer production sites contain. Objective: We designed a profile aggregation tool—Visual Resume—that aggregates contribution information across two types of peer production sites: a code hosting site (GitHub) and a technical Q&amp;A forum (Stack Overflow). Visual Resume displays summaries of developers' contributions and allows easy access to their contribution details. It also facilitates pairwise comparisons of candidates through a card-based design. We present the motivation for such a design and design guidelines for creating such recruitment tool.
Methods: We performed a scenario-based evaluation to identify how participants use developers' online contributions in peer production sites as well as how they used Visual Resume when making hiring decisions. Results: Our analysis helped in identifying the technical and soft skill cues that were most useful to our participants when making hiring decisions in online production sites. We also identified the information features that participants used and the ways the participants accessed that information to select a candidate. Conclusions: Our results suggest that Visual Resume helps in participants evaluate cues for technical and soft skills more efficiently as it presents an aggregated view of candidate's contributions, allows drill down to details about contributions, and allows easy comparison of candidates via movable cards that could be arranged to match participants' needs.</blockquote>

<h2 id="L">L</h2>

<p id="Lamba2020" class="bib"><cite>Lamba2020</cite>
Hemank Lamba, Asher Trockman, Daniel Armanios, Christian Kästner, Heather Miller, and Bogdan Vasilescu:
"<a href="https://doi.org/10.1145/3368089.3409705">Heard it through the Gitvine: an empirical study of tool diffusion across the npm ecosystem</a>".
<em>Proc. European Software Engineering Conference/International Symposium on the Foundations of Software Engineering (ESEC/FSE)</em>, 2020, <a class="doi" href="https://doi.org/10.1145/3368089.3409705">10.1145/3368089.3409705</a>.
</p>
<blockquote class="abstract">Automation tools like continuous integration services, code coverage reporters, style checkers, dependency managers, etc. are all known to provide significant improvements in developer productivity and software quality. Some of these tools are widespread, others are not. How do these automation ``best practices'' spread? And how might we facilitate the diffusion process for those that have seen slower adoption? In this paper, we rely on a recent innovation in transparency on code hosting platforms like GitHub—the use of repository badges—to track how automation tools spread in open-source ecosystems through different social and technical mechanisms over time. Using a large longitudinal data set, multivariate network science techniques, and survival analysis, we study which socio-technical factors can best explain the observed diffusion process of a number of popular automation tools. Our results show that factors such as social exposure, competition, and observability affect the adoption of tools significantly, and they provide a roadmap for software engineers and researchers seeking to propagate best practices and tools.</blockquote>

<h2 id="M">M</h2>

<p id="May2019" class="bib"><cite>May2019</cite>
Anna May, Johannes Wachs, and Anikó Hannák:
"<a href="https://doi.org/10.1007/s10664-019-09685-x">Gender differences in participation and reward on Stack Overflow</a>".
<em>Empirical Software Engineering</em>, 24(4), 2019,
<a class="doi" href="https://doi.org/10.1007/s10664-019-09685-x">10.1007/s10664-019-09685-x</a>.
</p>
<blockquote class="abstract">Programming is a valuable skill in the labor market, making the underrepresentation of women in computing an increasingly important issue. Online question and answer platforms serve a dual purpose in this field: they form a body of knowledge useful as a reference and learning tool, and they provide opportunities for individuals to demonstrate credible, verifiable expertise. Issues, such as male-oriented site design or overrepresentation of men among the site's elite may therefore compound the issue of women's underrepresentation in IT. In this paper we audit the differences in behavior and outcomes between men and women on Stack Overflow, the most popular of these Q&amp;A sites. We observe significant differences in how men and women participate in the platform and how successful they are. For example, the average woman has roughly half of the reputation points, the primary measure of success on the site, of the average man. Using an Oaxaca-Blinder decomposition, an econometric technique commonly applied to analyze differences in wages between groups, we find that most of the gap in success between men and women can be explained by differences in their activity on the site and differences in how these activities are rewarded. Specifically, 1) men give more answers than women and 2) are rewarded more for their answers on average, even when controlling for possible confounders such as tenure or buy-in to the site. Women ask more questions and gain more reward per question. We conclude with a hypothetical redesign of the site's scoring system based on these behavioral differences, cutting the reputation gap in half.</blockquote>

<h2 id="N">N</h2>
<h2 id="O">O</h2>

<p id="Olejniczak2020" class="bib"><cite>Olejniczak2020</cite>
Anthony J. Olejniczak and Molly J. Wilson:
"<a href="https://doi.org/10.1162/qss_a_00091">Who's writing open access (OA) articles? Characteristics of OA authors at Ph.D.-granting institutions in the United States</a>".
<em>Quantitative Science Studies</em>, 1(4), 2020,
<a class="doi" href="https://doi.org/10.1162/qss_a_00091">10.1162/qss_a_00091</a>.
</p>
<blockquote class="abstract">The open access (OA) publication movement aims to present research literature to the public at no cost and with no restrictions. While the democratization of access to scholarly literature is a primary focus of the movement, it remains unclear whether OA has uniformly democratized the corpus of freely available research, or whether authors who choose to publish in OA venues represent a particular subset of scholars—those with access to resources enabling them to afford article processing charges (APCs). We investigated the number of OA articles with article processing charges (APC OA) authored by 182,320 scholars with known demographic and institutional characteristics at American research universities across 11 broad fields of study. The results show, in general, that the likelihood for a scholar to author an APC OA article increases with male gender, employment at a prestigious institution (AAU member universities), association with a STEM discipline, greater federal research funding, and more advanced career stage (i.e., higher professorial rank). Participation in APC OA publishing appears to be skewed toward scholars with greater access to resources and job security.</blockquote>

<h2 id="P">P</h2>

<p id="Palomba2021" class="bib"><cite>Palomba2021</cite>
Fabio Palomba, Damian Andrew Tamburri, Francesca Arcelli Fontana, Rocco Oliveto, Andy Zaidman, and Alexander Serebrenik:
"<a href="https://doi.org/10.1109/tse.2018.2883603">Beyond Technical Aspects: How Do Community Smells Influence the Intensity of Code Smells?</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(1), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2018.2883603">10.1109/tse.2018.2883603</a>.
</p>
<blockquote class="abstract">Code smells are poor implementation choices applied by developers during software evolution that often lead to critical flaws or failure. Much in the same way, community smells reflect the presence of organizational and socio-technical issues within a software community that may lead to additional project costs. Recent empirical studies provide evidence that community smells are often—if not always—connected to circumstances such as code smells. In this paper we look deeper into this connection by conducting a mixed-methods empirical study of 117 releases from 9 open-source systems. The qualitative and quantitative sides of our mixed-methods study were run in parallel and assume a mutually-confirmative connotation. On the one hand, we survey 162 developers of the 9 considered systems to investigate whether developers perceive relationship between community smells and the code smells found in those projects. On the other hand, we perform a fine-grained analysis into the 117 releases of our dataset to measure the extent to which community smells impact code smell intensity (i.e., criticality). We then propose a code smell intensity prediction model that relies on both technical and community-related aspects. The results of both sides of our mixed-methods study lead to one conclusion: community-related factors contribute to the intensity of code smells. This conclusion supports the joint use of community and code smells detection as a mechanism for the joint management of technical and social problems around software development communities.</blockquote>

<p id="Poulos2021" class="bib"><cite>Poulos2021</cite>
Alexandra Poulos, Sally A. McKee, and Jon C. Calhoun:
"<a href="https://doi.org/10.1002/spe.3022">Posits and the state of numerical representations in the age of exascale and edge computing</a>".
<em>Software: Practice and Experience</em>, 52(2), 2021,
<a class="doi" href="https://doi.org/10.1002/spe.3022">10.1002/spe.3022</a>.
</p>
<blockquote class="abstract">Growing constraints on memory utilization, power consumption, and I/O throughput have increasingly become limiting factors to the advancement of high performance computing (HPC) and edge computing applications. IEEE-754 floating-point types have been the de facto standard for floating-point number systems for decades, but the drawbacks of this numerical representa- tion leave much to be desired. Alternative representations are gaining traction, both in HPC and machine learning environments. Posits have recently been proposed as a drop-in replacement for the IEEE-754 floating-point representa- tion. We survey the state-of-the-art and state-of-the-practice in the development and use of posits in edge computing and HPC. The current literature supports posits as a promising alternative to traditional floating-point systems, both as a stand-alone replacement and in a mixed-precision environment. Development and standardization of the posit type is ongoing, and much research remains to explore the application of posits in different domains, how to best implement them in hardware, and where they fit with other numerical representations.</blockquote>

<h2 id="Q">Q</h2>
<h2 id="R">R</h2>

<p id="Rahman2020b" class="bib"><cite>Rahman2020b</cite>
Mohammad Masudur Rahman, Foutse Khomh, and Marco Castelluccio:
"<a href="https://doi.org/10.1109/icsme46990.2020.00063">Why are Some Bugs Non-Reproducible? An Empirical Investigation using Data Fusion</a>".
<em>Proc. International Conference on Software Maintenance and Evolution (ICSME)</em>, 2020, <a class="doi" href="https://doi.org/10.1109/icsme46990.2020.00063">10.1109/icsme46990.2020.00063</a>.
</p>
<blockquote class="abstract">Software developers attempt to reproduce software bugs to understand their erroneous behaviours and to fix them. Unfortunately, they often fail to reproduce (or fix) them, which leads to faulty, unreliable software systems. However, to date, only a little research has been done to better understand what makes the software bugs non-reproducible. In this paper, we conduct a multimodal study to better understand the non-reproducibility of software bugs. First, we perform an empirical study using 576 non-reproducible bug reports from two popular software systems (Firefox, Eclipse) and identify 11 key factors that might lead a reported bug to non-reproducibility. Second, we conduct a user study involving 13 professional developers where we investigate how the developers cope with non-reproducible bugs. We found that they either close these bugs or solicit for further information, which involves long deliberations and counter-productive manual searches. Third, we offer several actionable insights on how to avoid non-reproducibility (e.g., false-positive bug report detector) and improve reproducibility of the reported bugs (e.g., sandbox for bug reproduction) by combining our analyses from multiple studies (e.g., empirical study, developer study).</blockquote>

<p id="Rahman2021" class="bib"><cite>Rahman2021</cite>
Akond Rahman, Md Rayhanur Rahman, Chris Parnin, and Laurie Williams:
"<a href="https://doi.org/10.1145/3408897">Security Smells in Ansible and Chef Scripts</a>".
<em>ACM Transactions on Software Engineering and Methodology</em>, 30(1), 2021,
<a class="doi" href="https://doi.org/10.1145/3408897">10.1145/3408897</a>.
</p>
<blockquote class="abstract">Context: Security smells are recurring coding patterns that are indicative of security weakness and require further inspection. As infrastructure as code (IaC) scripts, such as Ansible and Chef scripts, are used to provision cloud-based servers and systems at scale, security smells in IaC scripts could be used to enable malicious users to exploit vulnerabilities in the provisioned systems. Goal: The goal of this article is to help practitioners avoid insecure coding practices while developing infrastructure as code scripts through an empirical study of security smells in Ansible and Chef scripts. Methodology: We conduct a replication study where we apply qualitative analysis with 1,956 IaC scripts to identify security smells for IaC scripts written in two languages: Ansible and Chef. We construct a static analysis tool called Security Linter for Ansible and Chef scripts (SLAC) to automatically identify security smells in 50,323 scripts collected from 813 open source software repositories. We also submit bug reports for 1,000 randomly selected smell occurrences. Results: We identify two security smells not reported in prior work: missing default in case statement and no integrity check. By applying SLAC we identify 46,600 occurrences of security smells that include 7,849 hard-coded passwords. We observe agreement for 65 of the responded 94 bug reports, which suggests the relevance of security smells for Ansible and Chef scripts amongst practitioners. Conclusion: We observe security smells to be prevalent in Ansible and Chef scripts, similarly to that of the Puppet scripts. We recommend practitioners to rigorously inspect the presence of the identified security smells in Ansible and Chef scripts using (i) code review, and (ii) static analysis tools.</blockquote>

<h2 id="S">S</h2>
<h2 id="T">T</h2>

<p id="Turk2021" class="bib"><cite>Turk2021</cite>
Tomaž Turk:
"<a href="https://doi.org/10.1002/spe.3027">SDFunc: Modular spreadsheet design with sheet-defined functions in Microsoft Excel</a>".
<em>Software: Practice and Experience</em>, 52(2), 2021,
<a class="doi" href="https://doi.org/10.1002/spe.3027">10.1002/spe.3027</a>.
</p>
<blockquote class="abstract">The goal of the SDFunc tool is to enable spreadsheet developers to build their model computations in Microsoft Excel according to the modular design approach, that is, the separation of the functionalities into independent, interchangeable modules with interfaces that provide input and output elements. This concept has been theoretically developed in recent years and is known as sheet-defined functions in the literature. In this article, we are presenting our implementation of the tool and the evaluation steps that we took to make the tool interesting and suitable for the assessment of the modular approach in spreadsheet development by the industry, specifically within organizational and companies' settings where the spreadsheet developers and end-users involved in experiments expect to use a well-established spreadsheet platform. We also demonstrated that sheet-defined functions can be implemented by development tools already present in Microsoft Excel.</blockquote>

<h2 id="U">U</h2>
<h2 id="V">V</h2>

<p id="Vidoni2021" class="bib"><cite>Vidoni2021</cite>
Melina Vidoni:
"<a href="https://doi.org/10.1109/icse43902.2021.00136">Evaluating Unit Testing Practices in R Packages</a>".
<em>2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00136">10.1109/icse43902.2021.00136</a>.
</p>
<blockquote class="abstract">"Testing Technical Debt (TTD) occurs due to shortcuts (non-optimal decisions) taken about testing; it is the test dimension of technical debt. R is a package-based programming ecosystem that provides an easy way to install third-party code, datasets, tests, documentation and examples. This structure makes it especially vulnerable to TTD because errors present in a package can transitively affect all packages and scripts that depend on it. Thus, TTD can effectively become a threat to the validity of all analysis written in R that rely on potentially faulty code. This two-part study provides the first analysis in this area. First, 177 systematically-selected, open-source R packages were mined and analysed to address quality of testing, testing goals, and identify potential TTD sources. Second, a survey addressed how R package developers perceive testing and face its challenges (response rate of 19.4%). Results show that testing in R packages is of low quality; the most common smells are inadequate and obscure unit testing, improper asserts, inexperienced testers and improper test design. Furthermore, skilled R developers still face challenges such as time constraints, emphasis on development rather than testing, poor tool documentation and a steep learning curve."</blockquote>

<p id="Vidoni2022" class="bib"><cite>Vidoni2022</cite>
Melina Vidoni:
"<a href="https://doi.org/10.1016/j.jss.2022.111265">Understanding Roxygen package documentation in R</a>".
<em>Journal of Systems and Software</em>, 188, 2022,
<a class="doi" href="https://doi.org/10.1016/j.jss.2022.111265">10.1016/j.jss.2022.111265</a>.
</p>
<blockquote class="abstract">R is a package-based programming ecosystem that provides an easy way to install third-party code, datasets, and examples. Thus, R developers rely heavily on the documentation of the packages they import to use them correctly and accurately. This documentation is often written using Roxygen, equivalent to Java's well-known Javadoc. This two-part study provides the first analysis in this area. First, 379 systematically-selected, open-source R packages were mined and analysed to address the quality of their documentation in terms of presence, distribution, and completeness to identify potential sources of documentation debt of technical debt that describes problems in the documentation. Second, a survey addressed how R package developers perceive documentation and face its challenges (with a response rate of 10.04%). Results show that incomplete documentation is the most common smell, with several cases of incorrect use of the Roxygen utilities. Unlike in traditional API documentation, developers do not focus on how behaviour is implemented but on common use cases and parameter documentation. Respondents considered the examples section the most useful, and commonly perceived challenges were unexplained examples, ambiguity, incompleteness and fragmented information.</blockquote>

<h2 id="W">W</h2>
<h2 id="X">X</h2>
<h2 id="Y">Y</h2>

<p id="Young2021" class="bib"><cite>Young2021</cite>
Jean-Gabriel Young, Amanda Casari, Katie McLaughlin, Milo Z. Trujillo, Laurent Hebert-Dufresne, and James P. Bagrow:
"<a href="https://doi.org/10.1109/msr52588.2021.00036">Which contributions count? Analysis of attribution in open source</a>".
<em>Proc. International Conference on Mining Software Repositories (MSR)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00036">10.1109/msr52588.2021.00036</a>.
</p>
<blockquote class="abstract">Open source software projects usually acknowledge contributions with text files, websites, and other idiosyncratic methods. These data sources are hard to mine, which is why contributorship is most frequently measured through changes to repositories, such as commits, pushes, or patches. Recently, some open source projects have taken to recording contributor actions with standardized systems; this opens up a unique opportunity to understand how community-generated notions of contributorship map onto codebases as the measure of contribution. Here, we characterize contributor acknowledgment models in open source by analyzing thousands of projects that use a model called All Contributors to acknowledge diverse contributions like outreach, finance, infrastructure, and community management. We analyze the life cycle of projects through this model's lens and contrast its representation of contributorship with the picture given by other methods of acknowledgment, including GitHub's top committers indicator and contributions derived from actions taken on the platform. We find that community-generated systems of contribution acknowledgment make work like idea generation or bug finding more visible, which generates a more extensive picture of collaboration. Further, we find that models requiring explicit attribution lead to more clearly defined boundaries around what is and is not a contribution.</blockquote>

<h2 id="Z">Z</h2>

<p id="Zerouali2021" class="bib"><cite>Zerouali2021</cite>
Ahmed Zerouali, Tom Mens, and Coen De Roover:
"<a href="https://doi.org/10.1016/j.scico.2021.102653">On the usage of JavaScript, Python and Ruby packages in Docker Hub images</a>".
<em>Science of Computer Programming</em>, 207, 2021,
<a class="doi" href="https://doi.org/10.1016/j.scico.2021.102653">10.1016/j.scico.2021.102653</a>.
</p>
<blockquote class="abstract">Docker is one of the most popular containerization technologies. A Docker container can be saved into an image including all environmental packages required to run it, such as system and third-party packages from language-specific package repositories. Relying on its modularity, an image can be shared and included in other images to simplify the way of building and packaging new software. However, some package managers allow to include duplicated packages in an image, increasing its footprint; and outdated packages may miss new features and bug fixes or contain reported security vulnerabilities, putting the image in which they are contained at risk. Previous research has focused on studying operating system packages within Docker images, but little attention has been given to third-party packages. This article empirically studies installation practices, outdatedness and vulnerabilities of JavaScript, Python and Ruby packages installed in 3,000 popular community Docker Hub images. In many cases, these installed packages missed important releases leading to potential vulnerabilities of the images. Our findings suggest that maintainers of Docker Hub community images should invest more effort in updating outdated packages contained in those images in order to significantly reduce the number of vulnerabilities. In addition to this, Python community images are generally much less outdated and much less subject to vulnerabilities than NodeJS and Ruby community images. Specifically for NodeJS community images, elimination of duplicate package releases could lead to a significant reduction in their image footprint.</blockquote>
